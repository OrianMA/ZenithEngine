#include "ZenithApp.h"

#include <iostream>
#include <filesystem>


static const std::string ASSETS_PATH = "../assets/";

void ZenithApp::drawCurrentModel(CurrentModel& cur, Shader& shaderProgram, Camera& camera,
                                 const glm::vec3& modelPos,
                                 const glm::quat& modelRot,
                                 const glm::vec3& modelScale)
{
    if (std::holds_alternative<Model>(cur)) {
        std::get<Model>(cur).Draw(shaderProgram, camera, modelPos, modelRot, modelScale);
    } else if (std::holds_alternative<FBXModel>(cur)) {
        std::get<FBXModel>(cur).Draw(shaderProgram, camera, modelPos, modelRot, modelScale);
    }
}

int ZenithApp::run()
{
    // Initialize GLFW
    if (!glfwInit()) {
        std::cerr << "Failed to init GLFW\n";
        return -1;
    }

    // OpenGL 3.3 core
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // Create a movable windowed mode window (not exclusive fullscreen)
    GLFWmonitor* monitor = glfwGetPrimaryMonitor();
    const GLFWvidmode* mode = glfwGetVideoMode(monitor);
    int scrWidth = 1280;
    int scrHeight = 720;
    GLFWwindow* window = glfwCreateWindow(scrWidth, scrHeight, "Zenith Engine", nullptr, nullptr);
    if (!window) {
        std::cerr << "Failed to create GLFW window\n";
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);

    // Center the window on the primary monitor work area (keeps taskbar accessible)
#if GLFW_VERSION_MAJOR >= 3
    int wx = 0, wy = 0, ww = 0, wh = 0;
    int mx = 0, my = 0, mw = 0, mh = 0;
#ifdef GLFW_MOUSE_PASSTHROUGH // use as proxy for newer GLFW with workarea
    glfwGetMonitorWorkarea(monitor, &mx, &my, &mw, &mh);
#else
    // Fallback: use video mode if workarea is unavailable
    mx = 0; my = 0; mw = mode ? mode->width : 1920; mh = mode ? mode->height : 1080;
#endif
    glfwGetWindowSize(window, &ww, &wh);
    wx = mx + (mw - ww) / 2;
    wy = my + (mh - wh) / 2;
    glfwSetWindowPos(window, wx, wy);
#endif

    // Load GLAD
    if (!gladLoadGL()) {
        std::cerr << "Failed to load GL via GLAD\n";
        glfwDestroyWindow(window);
        glfwTerminate();
        return -1;
    }

    // Initialize viewport from actual framebuffer size (handles HiDPI and resizing)
    int fbWidth = 0, fbHeight = 0;
    glfwGetFramebufferSize(window, &fbWidth, &fbHeight);
    if (fbWidth <= 0 || fbHeight <= 0) { fbWidth = scrWidth; fbHeight = scrHeight; }
    glViewport(0, 0, fbWidth, fbHeight);

    // Shader selection (multiple variants share the same vertex shader)
    struct ShaderPreset { const char* name; const char* frag; ImVec4 clear; };
    std::vector<ShaderPreset> shaderPresets = {
        {"Default",      "default.frag",       ImVec4(0.07f, 0.13f, 0.17f, 1.0f)},
        {"Warm",         "default_warm.frag",  ImVec4(0.15f, 0.06f, 0.04f, 1.0f)},
        {"Cool",         "default_cool.frag",  ImVec4(0.02f, 0.08f, 0.14f, 1.0f)},
        {"Toon",         "default_toon.frag",  ImVec4(0.10f, 0.10f, 0.12f, 1.0f)},
        {"Grayscale",    "default_gray.frag",  ImVec4(0.12f, 0.12f, 0.12f, 1.0f)},
    };
    int currentShaderIdx = 0;
    auto makeShader = [&](int idx) {
        if (idx < 0 || idx >= (int)shaderPresets.size()) idx = 0;
        return Shader((ASSETS_PATH + std::string("default.vert")).c_str(),
                      (ASSETS_PATH + std::string(shaderPresets[idx].frag)).c_str());
    };
    Shader shaderProgram = makeShader(currentShaderIdx);

    // Light settings & visualization
    enum class LightType { Directional = 0, Point = 1, Spot = 2 };
    LightType lightType = LightType::Directional;
    glm::vec4 lightColor = glm::vec4(1.0f);
    glm::vec3 lightPos = glm::vec3(0.5f, 0.5f, 0.5f);
    glm::vec3 lightDir = glm::vec3(0.0f, 0.0f, -1.0f); // default to "north"
    float spotInner = 0.95f;
    float spotOuter = 0.90f;

    // GL state
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);

    // Camera
    Camera camera(scrWidth, scrHeight, glm::vec3(0.0f, 0.0f, 2.0f));

    // Simple cube to visualize point light
    GLuint lightVAO = 0, lightVBO = 0, lightEBO = 0;
    Shader lightShader((ASSETS_PATH + std::string("light.vert")).c_str(),
                       (ASSETS_PATH + std::string("light.frag")).c_str());
    {
        float vertices[] = {
            -0.5f,-0.5f,-0.5f,  0.5f,-0.5f,-0.5f,  0.5f, 0.5f,-0.5f, -0.5f, 0.5f,-0.5f,
            -0.5f,-0.5f, 0.5f,  0.5f,-0.5f, 0.5f,  0.5f, 0.5f, 0.5f, -0.5f, 0.5f, 0.5f,
        };
        unsigned int indices[] = {
            0,1,2, 2,3,0, // back
            4,5,6, 6,7,4, // front
            0,4,7, 7,3,0, // left
            1,5,6, 6,2,1, // right
            3,2,6, 6,7,3, // top
            0,1,5, 5,4,0  // bottom
        };
        glGenVertexArrays(1, &lightVAO);
        glGenBuffers(1, &lightVBO);
        glGenBuffers(1, &lightEBO);
        glBindVertexArray(lightVAO);
        glBindBuffer(GL_ARRAY_BUFFER, lightVBO);
        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, lightEBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
        glEnableVertexAttribArray(0);
        glBindVertexArray(0);
    }

    // Presets list
    std::vector<Preset> presets = {
        {"Violin (FBX)", ASSETS_PATH + std::string("Models/Violin/Violin.fbx"), Preset::Type::FBX},
        {"TestModel (FBX)", ASSETS_PATH + std::string("Models/TestModelFBX/TestModel.fbx"), Preset::Type::FBX},
        {"Adam Head (GLTF)", ASSETS_PATH + std::string("Models/adamHead/adamHead.gltf"), Preset::Type::GLTF},
        {"BoomBox (GLTF)", ASSETS_PATH + std::string("Models/boomBox/BoomBox.gltf"), Preset::Type::GLTF},
        {"Trees (GLTF)", ASSETS_PATH + std::string("Models/trees/scene.gltf"), Preset::Type::GLTF},
    };

    int selectedPreset = -1;
    CurrentModel currentModel = std::monostate{};

    auto loadPreset = [&](int idx){
        if (idx < 0 || idx >= (int)presets.size()) return;
        const Preset& p = presets[idx];

        // Validate file exists before attempting to load
        if (!std::filesystem::exists(p.path)) {
            std::cerr << "[Load] File does not exist: " << p.path << "\n";
            return;
        }

        bool loaded = false;
        if (p.type == Preset::Type::GLTF) {
            try {
                // Construct in-place; if constructor throws, variant remains unchanged
                currentModel.emplace<Model>(p.path.c_str());
                loaded = true;
            } catch (const std::exception& e) {
                std::cerr << "[Load] Failed to load GLTF model: " << p.path << " | " << e.what() << "\n";
            } catch (...) {
                std::cerr << "[Load] Failed to load GLTF model: " << p.path << " | unknown error\n";
            }
        } else {
            try {
                // Build a temporary FBXModel to verify it actually has meshes
                FBXModel tmp(p.path.c_str());
                if (tmp.meshCount() == 0) {
                    std::cerr << "[Load] FBX has 0 meshes (skipping): " << p.path << "\n";
                } else {
                    currentModel = std::move(tmp);
                    loaded = true;
                }
            } catch (const std::exception& e) {
                std::cerr << "[Load] Failed to load FBX model: " << p.path << " | " << e.what() << "\n";
            } catch (...) {
                std::cerr << "[Load] Failed to load FBX model: " << p.path << " | unknown error\n";
            }
        }

        if (loaded) {
            selectedPreset = idx;
        } else {
            // Keep previous state unchanged on failure
            std::cerr << "[Load] Keeping previous model (load failed).\n";
        }
    };

    // ImGui setup
    ImGuiLayer imgui(window, "#version 330");

    // FPS counter
    double prevTime = 0.0;
    double crntTime = 0.0;
    double timeDiff;
    unsigned int counter = 0;

    // Track fullscreen-like borderless state and last windowed placement
    bool borderless = false;
    int savedX = 0, savedY = 0, savedW = scrWidth, savedH = scrHeight;
    bool f11Prev = false;

    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
            glfwSetWindowShouldClose(window, true);
        }

        crntTime = glfwGetTime();
        timeDiff = crntTime - prevTime;
        counter++;
        if (timeDiff >= 1.0 / 30.0) {
            std::string FPS = std::to_string((1.0 / timeDiff) * counter);
            std::string ms = std::to_string((timeDiff / counter) * 1000);
            std::string title = "Zenith Engine - " + FPS + "FPS / " + ms + "ms";
            if (selectedPreset >= 0 && selectedPreset < (int)presets.size()) {
                title += " | ";
                title += presets[selectedPreset].name;
            } else {
                title += " | No Model";
            }
            glfwSetWindowTitle(window, title.c_str());
            prevTime = crntTime;
            counter = 0;
        }

        // Handle dynamic resize: update viewport and camera aspect
        int curFbW = 0, curFbH = 0;
        glfwGetFramebufferSize(window, &curFbW, &curFbH);
        if (curFbW > 0 && curFbH > 0) {
            if (curFbW != fbWidth || curFbH != fbHeight) {
                fbWidth = curFbW; fbHeight = curFbH;
                glViewport(0, 0, fbWidth, fbHeight);
                camera.width = fbWidth;
                camera.height = fbHeight;
            }
        }

        // Apply background color based on selected shader preset
        ImVec4 cc = shaderPresets[currentShaderIdx].clear;
        glClearColor(cc.x, cc.y, cc.z, cc.w);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        // Start ImGui frame first to know if UI wants mouse
        imgui.beginFrame();

        // Toggle borderless (windowed fullscreen) with F11
        bool f11Now = glfwGetKey(window, GLFW_KEY_F11) == GLFW_PRESS;
        if (f11Now && !f11Prev) {
            if (!borderless) {
                // Save current windowed placement
                glfwGetWindowPos(window, &savedX, &savedY);
                glfwGetWindowSize(window, &savedW, &savedH);
                // Use monitor work area to keep taskbar accessible
                int mx = 0, my = 0, mw = 0, mh = 0;
#ifdef GLFW_MOUSE_PASSTHROUGH
                glfwGetMonitorWorkarea(monitor, &mx, &my, &mw, &mh);
#else
                mx = 0; my = 0; mw = mode ? mode->width : 1920; mh = mode ? mode->height : 1080;
#endif
                glfwSetWindowAttrib(window, GLFW_DECORATED, GLFW_FALSE);
                glfwSetWindowPos(window, mx, my);
                glfwSetWindowSize(window, mw, mh);
                // Update viewport immediately after size change
                glfwGetFramebufferSize(window, &fbWidth, &fbHeight);
                if (fbWidth > 0 && fbHeight > 0) {
                    glViewport(0, 0, fbWidth, fbHeight);
                    camera.width = fbWidth;
                    camera.height = fbHeight;
                }
                borderless = true;
            } else {
                // Restore decorations and placement
                glfwSetWindowAttrib(window, GLFW_DECORATED, GLFW_TRUE);
                glfwSetWindowPos(window, savedX, savedY);
                glfwSetWindowSize(window, savedW, savedH);
                // Update viewport immediately after size change
                glfwGetFramebufferSize(window, &fbWidth, &fbHeight);
                if (fbWidth > 0 && fbHeight > 0) {
                    glViewport(0, 0, fbWidth, fbHeight);
                    camera.width = fbWidth;
                    camera.height = fbHeight;
                }
                borderless = false;
            }
        }
        f11Prev = f11Now;

        // Decide whether to capture mouse for camera (hide/lock cursor)
        ImGuiIO& io = ImGui::GetIO();
        bool uiWantsMouse = io.WantCaptureMouse;
        bool moveLook = (glfwGetMouseButton(window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS) && !uiWantsMouse;
        if (moveLook) {
            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
            camera.Inputs(window);
        } else {
            glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
            camera.firstClick = true; // ensure no jump when resuming
        }
        camera.updateMatrix(45.0f, 0.1f, 100.0f);

        // Update per-frame light uniforms
        shaderProgram.Activate();
        glUniform4f(glGetUniformLocation(shaderProgram.ID, "lightColor"), lightColor.x, lightColor.y, lightColor.z, lightColor.w);
        glUniform3f(glGetUniformLocation(shaderProgram.ID, "lightPos"), lightPos.x, lightPos.y, lightPos.z);
        glUniform1i(glGetUniformLocation(shaderProgram.ID, "uLightType"), (int)lightType);
        glUniform3f(glGetUniformLocation(shaderProgram.ID, "uLightDir"), lightDir.x, lightDir.y, lightDir.z);
        glUniform1f(glGetUniformLocation(shaderProgram.ID, "uSpotInner"), spotInner);
        glUniform1f(glGetUniformLocation(shaderProgram.ID, "uSpotOuter"), spotOuter);

        drawCurrentModel(currentModel, shaderProgram, camera);

        // Draw a tiny cube at point light position
        if (lightType == LightType::Point) {
            lightShader.Activate();
            glUniform4f(glGetUniformLocation(lightShader.ID, "lightColor"), lightColor.x, lightColor.y, lightColor.z, lightColor.w);
            camera.Matrix(lightShader, "camMatrix");
            glm::mat4 model = glm::mat4(1.0f);
            model = glm::translate(model, lightPos);
            model = glm::scale(model, glm::vec3(0.03f));
            glUniformMatrix4fv(glGetUniformLocation(lightShader.ID, "model"), 1, GL_FALSE, glm::value_ptr(model));
            glBindVertexArray(lightVAO);
            glDrawElements(GL_TRIANGLES, 36, GL_UNSIGNED_INT, 0);
            glBindVertexArray(0);
        }

        ImGui::SetNextWindowPos(ImVec2(10, 10), ImGuiCond_Once);
        ImGui::SetNextWindowSize(ImVec2(260, 300), ImGuiCond_Once);
        if (ImGui::Begin("Models")) {
            for (int i = 0; i < (int)presets.size(); ++i) {
                bool isSelected = (i == selectedPreset);
                if (ImGui::Selectable(presets[i].name.c_str(), isSelected)) {
                    std::cout << "Loading preset: " << presets[i].name << std::endl;
                    loadPreset(i);
                }
            }
            if (ImGui::Button("Unload Model")) {
                // Idempotent unload: reset to empty state
                currentModel = std::monostate{};
                selectedPreset = -1;
                std::cerr << "[Unload] Model cleared.\n";
            }
        }
        ImGui::End();

        // Shaders window
        ImGui::SetNextWindowPos(ImVec2(280, 10), ImGuiCond_Once);
        ImGui::SetNextWindowSize(ImVec2(240, 220), ImGuiCond_Once);
        if (ImGui::Begin("Shaders")) {
            for (int i = 0; i < (int)shaderPresets.size(); ++i) {
                bool sel = (i == currentShaderIdx);
                if (ImGui::Selectable(shaderPresets[i].name, sel)) {
                    // Replace current shader with new selection
                    shaderProgram.Delete();
                    currentShaderIdx = i;
                    shaderProgram = makeShader(currentShaderIdx);
                }
            }
            ImGui::Separator();
            ImVec4 c = shaderPresets[currentShaderIdx].clear;
            ImGui::Text("Clear: R=%.2f G=%.2f B=%.2f", c.x, c.y, c.z);
        }
        ImGui::End();

        // Lights window
        ImGui::SetNextWindowPos(ImVec2(530, 10), ImGuiCond_Once);
        ImGui::SetNextWindowSize(ImVec2(320, 260), ImGuiCond_Once);
        if (ImGui::Begin("Lights")) {
            // Light type selection, replaces the current type when changed
            int lt = (int)lightType;
            if (ImGui::RadioButton("Directional", lt == 0)) { lightType = LightType::Directional; lt = 0; }
            ImGui::SameLine();
            if (ImGui::RadioButton("Point", lt == 1)) { lightType = LightType::Point; lt = 1; }
            ImGui::SameLine();
            if (ImGui::RadioButton("Spot", lt == 2)) { lightType = LightType::Spot; lt = 2; }

            ImGui::Separator();
            // Color picker for current light
            ImGui::ColorEdit3("Color", (float*)&lightColor);

            if (lightType == LightType::Directional) {
                ImGui::Text("Direction presets:");
                if (ImGui::Button("North"))  lightDir = glm::vec3(0, 0, -1);
                ImGui::SameLine();
                if (ImGui::Button("South"))   lightDir = glm::vec3(0, 0,  1);
                ImGui::SameLine();
                if (ImGui::Button("East"))   lightDir = glm::vec3(1, 0,  0);
                ImGui::SameLine();
                if (ImGui::Button("West")) lightDir = glm::vec3(-1, 0, 0);
            }

            if (lightType == LightType::Point) {
                ImGui::Text("Point position:");
                ImGui::DragFloat3("Pos", (float*)&lightPos, 0.01f);
            }

            if (lightType == LightType::Spot) {
                ImGui::Text("Spot origin & direction:");
                ImGui::DragFloat3("Pos", (float*)&lightPos, 0.01f);
                ImGui::DragFloat3("Dir", (float*)&lightDir, 0.01f, -1.0f, 1.0f);
                ImGui::SliderFloat("Inner", &spotInner, 0.0f, 1.0f);
                ImGui::SliderFloat("Outer", &spotOuter, 0.0f, spotInner);
            }
        }
        ImGui::End();

        imgui.endFrame();

        glfwSwapBuffers(window);
    }

    shaderProgram.Delete();
    lightShader.Delete();
    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}

