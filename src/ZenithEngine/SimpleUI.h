#pragma once

#include <glad/glad.h>
#ifndef GLFW_INCLUDE_NONE
#define GLFW_INCLUDE_NONE
#endif
#include <GLFW/glfw3.h>
#include <cstdio>

// Minimal immediate-mode style UI for rectangles and click detection.
// Coordinates are in pixels with origin at top-left of the window.
class SimpleUI {
public:
    inline SimpleUI(GLFWwindow* window, int screenW, int screenH)
        : m_window(window), m_w(screenW), m_h(screenH) {
        initGL();
    }

    inline ~SimpleUI() { destroyGL(); }

    inline void resize(int screenW, int screenH) { m_w = screenW; m_h = screenH; }

    // Begin a UI frame (sets GL state for overlay rendering)
    inline void beginFrame() {
        glDisable(GL_DEPTH_TEST);
        glDisable(GL_CULL_FACE);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        glUseProgram(m_prog);
        glBindVertexArray(m_vao);
        glBindBuffer(GL_ARRAY_BUFFER, m_vbo);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float)*2, (void*)0);
    }

    // End a UI frame (restores GL state)
    inline void endFrame() {
        glDisableVertexAttribArray(0);
        glBindBuffer(GL_ARRAY_BUFFER, 0);
        glBindVertexArray(0);
        glUseProgram(0);
        glDisable(GL_BLEND);
        glEnable(GL_CULL_FACE);
        glEnable(GL_DEPTH_TEST);
        int state = glfwGetMouseButton(m_window, GLFW_MOUSE_BUTTON_LEFT);
        m_prevMouseDown = (state == GLFW_PRESS);
    }

    // Draw a rectangle at x,y with size w,h and RGBA color in [0,1]
    inline void drawRect(float x, float y, float w, float h, float r, float g, float b, float a) {
        auto toNDC = [&](float px, float py) {
            float xn = (px / (float)m_w) * 2.0f - 1.0f;
            float yn = 1.0f - (py / (float)m_h) * 2.0f;
            return std::pair<float,float>(xn, yn);
        };

        float x0 = x, y0 = y, x1 = x + w, y1 = y + h;
        auto p0 = toNDC(x0, y0);
        auto p1 = toNDC(x1, y0);
        auto p2 = toNDC(x1, y1);
        auto p3 = toNDC(x0, y1);

        float verts[12] = {
            (float)p0.first, (float)p0.second,
            (float)p1.first, (float)p1.second,
            (float)p2.first, (float)p2.second,
            (float)p0.first, (float)p0.second,
            (float)p2.first, (float)p2.second,
            (float)p3.first, (float)p3.second,
        };

        glUniform4f(m_uColor, r, g, b, a);
        glBufferData(GL_ARRAY_BUFFER, sizeof(verts), verts, GL_STREAM_DRAW);
        glDrawArrays(GL_TRIANGLES, 0, 6);
    }

    // Button helper: draws a rect, returns true when clicked this frame
    inline bool button(float x, float y, float w, float h, float r, float g, float b, float a,
                       float rHover, float gHover, float bHover, float aHover,
                       float rActive, float gActive, float bActive, float aActive) {
        double mx = 0.0, my = 0.0;
        glfwGetCursorPos(m_window, &mx, &my);
        bool hovered = (mx >= x && mx <= (x + w) && my >= y && my <= (y + h));
        bool mouseDown = glfwGetMouseButton(m_window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS;
        bool clicked = hovered && mouseDown && !m_prevMouseDown;

        if (mouseDown && hovered) {
            drawRect(x, y, w, h, rActive, gActive, bActive, aActive);
        } else if (hovered) {
            drawRect(x, y, w, h, rHover, gHover, bHover, aHover);
        } else {
            drawRect(x, y, w, h, r, g, b, a);
        }
        return clicked;
    }

    // Very small bitmap font (5x7) text rendering
    inline void drawText(float x, float y, float scale, float r, float g, float b, float a, const char* text) {
        const unsigned char* s = reinterpret_cast<const unsigned char*>(text);
        const float cell = scale; // size of one pixel block
        const float charW = 6.0f * cell; // 5 pixels + 1 spacing
        while (*s) {
            unsigned char c = *s++;
            if (c < 32 || c > 127) { x += charW; continue; }
            const unsigned char* glyph = kFont5x7[c - 32];
            for (int row = 0; row < 7; ++row) {
                unsigned char bits = glyph[row];
                for (int col = 0; col < 5; ++col) {
                    if (bits & (1u << (4 - col))) {
                        drawRect(x + col * cell, y + row * cell, cell, cell, r, g, b, a);
                    }
                }
            }
            x += charW;
        }
    }

private:
    GLFWwindow* m_window {nullptr};
    int m_w {0}, m_h {0};
    bool m_prevMouseDown {false};

    GLuint m_prog {0};
    GLuint m_vao {0};
    GLuint m_vbo {0};
    GLint  m_uColor {-1};

    // Shader helpers
    static inline GLuint compileShader(GLenum type, const char* src) {
        GLuint s = glCreateShader(type);
        glShaderSource(s, 1, &src, nullptr);
        glCompileShader(s);
        GLint ok = GL_FALSE;
        glGetShaderiv(s, GL_COMPILE_STATUS, &ok);
        if (!ok) {
            char log[1024]; GLsizei len = 0;
            glGetShaderInfoLog(s, sizeof(log), &len, log);
            std::fprintf(stderr, "UI shader compile error: %.*s\n", (int)len, log);
        }
        return s;
    }

    static inline GLuint linkProgram(GLuint vs, GLuint fs) {
        GLuint p = glCreateProgram();
        glAttachShader(p, vs);
        glAttachShader(p, fs);
        glLinkProgram(p);
        GLint ok = GL_FALSE;
        glGetProgramiv(p, GL_LINK_STATUS, &ok);
        if (!ok) {
            char log[1024]; GLsizei len = 0;
            glGetProgramInfoLog(p, sizeof(log), &len, log);
            std::fprintf(stderr, "UI program link error: %.*s\n", (int)len, log);
        }
        glDetachShader(p, vs);
        glDetachShader(p, fs);
        glDeleteShader(vs);
        glDeleteShader(fs);
        return p;
    }

    inline void initGL() {
        ensureProgram();
        glGenVertexArrays(1, &m_vao);
        glGenBuffers(1, &m_vbo);
    }

    inline void destroyGL() {
        if (m_vbo) glDeleteBuffers(1, &m_vbo);
        if (m_vao) glDeleteVertexArrays(1, &m_vao);
        if (m_prog) glDeleteProgram(m_prog);
        m_vbo = m_vao = m_prog = 0;
    }

    inline void ensureProgram() {
        if (m_prog) return;
        static const char* kUIVert = R"(#version 330 core
layout(location=0) in vec2 aPos;
void main(){ gl_Position = vec4(aPos, 0.0, 1.0); }
)";
        static const char* kUIFrag = R"(#version 330 core
out vec4 FragColor;
uniform vec4 uColor;
void main(){ FragColor = uColor; }
)";
        GLuint vs = compileShader(GL_VERTEX_SHADER, kUIVert);
        GLuint fs = compileShader(GL_FRAGMENT_SHADER, kUIFrag);
        m_prog = linkProgram(vs, fs);
        m_uColor = glGetUniformLocation(m_prog, "uColor");
    }

    // 5x7 font bitmap, rows top-to-bottom; bit 4 is leftmost pixel.
    // Covers ASCII 32..127
    static inline const unsigned char kFont5x7[96][7] = {
        /* 32 ' ' */ {0,0,0,0,0,0,0},
        /* 33 '!' */ {0x04,0x04,0x04,0x04,0x00,0x00,0x04},
        /* 34 '"'*/ {0x0A,0x0A,0x0A,0x00,0x00,0x00,0x00},
        /* 35 '#' */ {0x0A,0x1F,0x0A,0x0A,0x1F,0x0A,0x0A},
        /* 36 '$' */ {0x04,0x1E,0x05,0x0E,0x14,0x0F,0x04},
        /* 37 '%' */ {0x19,0x19,0x02,0x04,0x08,0x13,0x13},
        /* 38 '&' */ {0x0C,0x12,0x14,0x08,0x15,0x12,0x0D},
        /* 39 '\''*/ {0x06,0x04,0x08,0x00,0x00,0x00,0x00},
        /* 40 '(' */ {0x02,0x04,0x08,0x08,0x08,0x04,0x02},
        /* 41 ')' */ {0x08,0x04,0x02,0x02,0x02,0x04,0x08},
        /* 42 '*' */ {0x00,0x04,0x15,0x0E,0x15,0x04,0x00},
        /* 43 '+' */ {0x00,0x04,0x04,0x1F,0x04,0x04,0x00},
        /* 44 ',' */ {0x00,0x00,0x00,0x00,0x06,0x04,0x08},
        /* 45 '-' */ {0x00,0x00,0x00,0x1F,0x00,0x00,0x00},
        /* 46 '.' */ {0x00,0x00,0x00,0x00,0x00,0x0C,0x0C},
        /* 47 '/' */ {0x01,0x01,0x02,0x04,0x08,0x10,0x10},
        /* 48 '0' */ {0x0E,0x11,0x13,0x15,0x19,0x11,0x0E},
        /* 49 '1' */ {0x04,0x0C,0x04,0x04,0x04,0x04,0x0E},
        /* 50 '2' */ {0x0E,0x11,0x01,0x02,0x04,0x08,0x1F},
        /* 51 '3' */ {0x1F,0x02,0x04,0x02,0x01,0x11,0x0E},
        /* 52 '4' */ {0x02,0x06,0x0A,0x12,0x1F,0x02,0x02},
        /* 53 '5' */ {0x1F,0x10,0x1E,0x01,0x01,0x11,0x0E},
        /* 54 '6' */ {0x06,0x08,0x10,0x1E,0x11,0x11,0x0E},
        /* 55 '7' */ {0x1F,0x01,0x02,0x04,0x08,0x08,0x08},
        /* 56 '8' */ {0x0E,0x11,0x11,0x0E,0x11,0x11,0x0E},
        /* 57 '9' */ {0x0E,0x11,0x11,0x0F,0x01,0x02,0x0C},
        /* 58 ':' */ {0x00,0x0C,0x0C,0x00,0x0C,0x0C,0x00},
        /* 59 ';' */ {0x00,0x0C,0x0C,0x00,0x0C,0x04,0x08},
        /* 60 '<' */ {0x02,0x04,0x08,0x10,0x08,0x04,0x02},
        /* 61 '=' */ {0x00,0x00,0x1F,0x00,0x1F,0x00,0x00},
        /* 62 '>' */ {0x08,0x04,0x02,0x01,0x02,0x04,0x08},
        /* 63 '?' */ {0x0E,0x11,0x01,0x02,0x04,0x00,0x04},
        /* 64 '@' */ {0x0E,0x11,0x01,0x0D,0x15,0x15,0x0E},
        /* 65 'A' */ {0x0E,0x11,0x11,0x1F,0x11,0x11,0x11},
        /* 66 'B' */ {0x1E,0x11,0x11,0x1E,0x11,0x11,0x1E},
        /* 67 'C' */ {0x0E,0x11,0x10,0x10,0x10,0x11,0x0E},
        /* 68 'D' */ {0x1E,0x11,0x11,0x11,0x11,0x11,0x1E},
        /* 69 'E' */ {0x1F,0x10,0x10,0x1E,0x10,0x10,0x1F},
        /* 70 'F' */ {0x1F,0x10,0x10,0x1E,0x10,0x10,0x10},
        /* 71 'G' */ {0x0E,0x11,0x10,0x17,0x11,0x11,0x0F},
        /* 72 'H' */ {0x11,0x11,0x11,0x1F,0x11,0x11,0x11},
        /* 73 'I' */ {0x0E,0x04,0x04,0x04,0x04,0x04,0x0E},
        /* 74 'J' */ {0x01,0x01,0x01,0x01,0x11,0x11,0x0E},
        /* 75 'K' */ {0x11,0x12,0x14,0x18,0x14,0x12,0x11},
        /* 76 'L' */ {0x10,0x10,0x10,0x10,0x10,0x10,0x1F},
        /* 77 'M' */ {0x11,0x1B,0x15,0x15,0x11,0x11,0x11},
        /* 78 'N' */ {0x11,0x19,0x15,0x13,0x11,0x11,0x11},
        /* 79 'O' */ {0x0E,0x11,0x11,0x11,0x11,0x11,0x0E},
        /* 80 'P' */ {0x1E,0x11,0x11,0x1E,0x10,0x10,0x10},
        /* 81 'Q' */ {0x0E,0x11,0x11,0x11,0x15,0x12,0x0D},
        /* 82 'R' */ {0x1E,0x11,0x11,0x1E,0x14,0x12,0x11},
        /* 83 'S' */ {0x0F,0x10,0x10,0x0E,0x01,0x01,0x1E},
        /* 84 'T' */ {0x1F,0x04,0x04,0x04,0x04,0x04,0x04},
        /* 85 'U' */ {0x11,0x11,0x11,0x11,0x11,0x11,0x0E},
        /* 86 'V' */ {0x11,0x11,0x11,0x11,0x11,0x0A,0x04},
        /* 87 'W' */ {0x11,0x11,0x11,0x15,0x15,0x1B,0x11},
        /* 88 'X' */ {0x11,0x11,0x0A,0x04,0x0A,0x11,0x11},
        /* 89 'Y' */ {0x11,0x11,0x0A,0x04,0x04,0x04,0x04},
        /* 90 'Z' */ {0x1F,0x01,0x02,0x04,0x08,0x10,0x1F},
        /* 91 '[' */ {0x0E,0x08,0x08,0x08,0x08,0x08,0x0E},
        /* 92 '\\'*/ {0x10,0x10,0x08,0x04,0x02,0x01,0x01},
        /* 93 ']' */ {0x0E,0x02,0x02,0x02,0x02,0x02,0x0E},
        /* 94 '^' */ {0x04,0x0A,0x11,0x00,0x00,0x00,0x00},
        /* 95 '_' */ {0x00,0x00,0x00,0x00,0x00,0x00,0x1F},
        /* 96 '`' */ {0x08,0x04,0x02,0x00,0x00,0x00,0x00},
        /* 97 'a' */ {0x00,0x00,0x0E,0x01,0x0F,0x11,0x0F},
        /* 98 'b' */ {0x10,0x10,0x1E,0x11,0x11,0x11,0x1E},
        /* 99 'c' */ {0x00,0x00,0x0E,0x10,0x10,0x10,0x0E},
        /*100 'd' */ {0x01,0x01,0x0F,0x11,0x11,0x11,0x0F},
        /*101 'e' */ {0x00,0x00,0x0E,0x11,0x1F,0x10,0x0E},
        /*102 'f' */ {0x06,0x08,0x1E,0x08,0x08,0x08,0x08},
        /*103 'g' */ {0x00,0x0F,0x11,0x11,0x0F,0x01,0x0E},
        /*104 'h' */ {0x10,0x10,0x1E,0x11,0x11,0x11,0x11},
        /*105 'i' */ {0x04,0x00,0x0C,0x04,0x04,0x04,0x0E},
        /*106 'j' */ {0x02,0x00,0x06,0x02,0x02,0x12,0x0C},
        /*107 'k' */ {0x10,0x10,0x12,0x14,0x18,0x14,0x12},
        /*108 'l' */ {0x0C,0x04,0x04,0x04,0x04,0x04,0x0E},
        /*109 'm' */ {0x00,0x00,0x1A,0x15,0x15,0x11,0x11},
        /*110 'n' */ {0x00,0x00,0x1E,0x11,0x11,0x11,0x11},
        /*111 'o' */ {0x00,0x00,0x0E,0x11,0x11,0x11,0x0E},
        /*112 'p' */ {0x00,0x00,0x1E,0x11,0x11,0x1E,0x10},
        /*113 'q' */ {0x00,0x00,0x0F,0x11,0x11,0x0F,0x01},
        /*114 'r' */ {0x00,0x00,0x16,0x19,0x10,0x10,0x10},
        /*115 's' */ {0x00,0x00,0x0F,0x10,0x0E,0x01,0x1E},
        /*116 't' */ {0x08,0x08,0x1E,0x08,0x08,0x08,0x06},
        /*117 'u' */ {0x00,0x00,0x11,0x11,0x11,0x11,0x0F},
        /*118 'v' */ {0x00,0x00,0x11,0x11,0x11,0x0A,0x04},
        /*119 'w' */ {0x00,0x00,0x11,0x11,0x15,0x1B,0x11},
        /*120 'x' */ {0x00,0x00,0x11,0x0A,0x04,0x0A,0x11},
        /*121 'y' */ {0x00,0x00,0x11,0x11,0x0F,0x01,0x0E},
        /*122 'z' */ {0x00,0x00,0x1F,0x02,0x04,0x08,0x1F},
        /*123 '{' */ {0x02,0x04,0x04,0x08,0x04,0x04,0x02},
        /*124 '|' */ {0x04,0x04,0x04,0x04,0x04,0x04,0x04},
        /*125 '}' */ {0x08,0x04,0x04,0x02,0x04,0x04,0x08},
        /*126 '~' */ {0x00,0x00,0x09,0x16,0x00,0x00,0x00},
        /*127     */ {0,0,0,0,0,0,0}
    };
};
